name: Release

on:
  push:
    branches:
      - master

permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  package_type: system
  package_id: yzecoriolis

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      # Create an initial release PR that changes will be tracked to.
      - uses: googleapis/release-please-action@v4
        id: release_pr
        with:
          release-type: simple

      # grab our branch from the above PR
      - uses: actions/github-script@v3
        id: checkout_branch
        if: ${{ steps.release_pr.outputs.pr && !steps.release_pr.outputs.release_created }}
        with:
          script: |
            const pr = ${{ steps.release_pr.outputs.pr }};
            const response = await github.pulls.get({
              pull_number: pr.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            core.info("ðŸŒ¿ branch ðŸŒ¿:" +  response.data.head.ref);
            core.setOutput("branch", response.data.head.ref);

      # checkout PR branch
      - uses: actions/checkout@v2
        with:
          ref: ${{ steps.checkout_branch.outputs.branch }}
        if: ${{ steps.release_pr.outputs.pr && !steps.release_pr.outputs.release_created }}

      # inject version into environment
      - if: ${{ steps.release_pr.outputs.pr && !steps.release_pr.outputs.release_created }}
        run: |
          echo "sys_version=$(cat ./version.txt)" >> $GITHUB_ENV
          cat ./version.txt

      # Updates the manifest and download URLS in system.json
      - name: Update system.json
        if: ${{ steps.release_pr.outputs.pr && !steps.release_pr.outputs.release_created }}
        uses: microsoft/variable-substitution@v1
        with:
          files: "system.json"
        env:
          version: ${{ env.sys_version }}
          manifest: https://github.com/${{github.repository}}/releases/latest/download/system.json
          download: https://github.com/${{github.repository}}/releases/download/v${{env.sys_version}}/coriolis.zip

      # with the initially opened PR, update our system.json
      - name: "Commit system.json"
        if: ${{ steps.release_pr.outputs.pr && !steps.release_pr.outputs.release_created }}
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add system.json
          git commit -m "ci: updated manifest data"
          git push

      # In the event we've created an actual release:
      # 1. zip up files
      # 2. and attach zip and manifest to the release.
      # 3. update FVTT admin panel with latest release metadata

      # checkout release branch
      - uses: actions/checkout@v2
        if: ${{ steps.release_pr.outputs.release_created }}

      # zip our assets
      - name: "Create Zipped Artifact"
        if: ${{ steps.release_pr.outputs.release_created }}
        run: zip -r ./coriolis.zip LICENSE README.md CHANGELOG.md system.json template.json css/ data/ images/ lang/ lib/ module/ packs/ templates/

      # upload zip artifact
      - name: "ðŸ“¦ Add coriolis.zip to Release ðŸ“¦"
        if: ${{ steps.release_pr.outputs.release_created }}
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: coriolis.zip
          asset_name: coriolis.zip
          tag: v${{ steps.release_pr.outputs.major }}.${{ steps.release_pr.outputs.minor }}.${{ steps.release_pr.outputs.patch }}
          overwrite: true

      # upload system manifest
      - name: "ðŸ“¦ Add system.json to Release ðŸ“¦"
        if: ${{ steps.release_pr.outputs.release_created }}
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: system.json
          asset_name: system.json
          tag: v${{ steps.release_pr.outputs.major }}.${{ steps.release_pr.outputs.minor }}.${{ steps.release_pr.outputs.patch }}
          overwrite: true

      # initialize go environment
      - uses: actions/setup-go@v2
        if: ${{ steps.release_pr.outputs.release_created }}
        with:
          go-version: "^1.16.5"

      - name: Get Compatibility
        if: ${{ steps.release_pr.outputs.release_created }}
        run: |
          echo 'COMPATIBILITY<<EOF' >> $GITHUB_ENV
          cat ${{ env.package_type }}.json | jq .compatibility >> $GITHUB_ENV
          echo 'EOF' >> $GITHUB_ENV

      - name: Send package to foundry
        if: ${{ steps.release_pr.outputs.release_created }}
        run: |
          HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}" -X POST 'https://foundryvtt.com/_api/packages/release_version/' \
          --header 'Authorization: ${{ secrets.PACKAGE_TOKEN }}' \
          --header 'Content-Type: application/json' \
          --data '{
              "id": "${{env.package_id}}",
              "dry-run": ${{github.event.release.prerelease}},
              "release": {
                  "version": "${{ steps.release_pr.outputs.tag_name }}",
                  "manifest": "https://github.com/${{github.repository}}/releases/download/${{steps.release_pr.outputs.tag_name}}/${{ env.package_type }}.json",
                  "notes": "https://github.com/${{github.repository}}/releases/tag/${{steps.release_pr.outputs.tag_name}}",
                  "compatibility": ${{ env.COMPATIBILITY }}
              }
          }')
          
          # extract the body
          HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
          
          # extract the status
          HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          
          # print the body
          echo "$HTTP_BODY"
          
          # example using the status
          if [ ! $HTTP_STATUS -eq 200  ]; then
            echo "Error [HTTP status: $HTTP_STATUS]"
            exit 1
          fi
